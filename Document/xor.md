A : [i + 1, j]
B : [0, i]
C : [0, j]

A == B ^ C
B == A ^ C

가능한 subarrary 의 누적 xor 합이 m 인 경우를 모두 count 한다. --- 1
이때 m은 제곱수들을 취급하므로 sqrt(2 * n)

1을 최적화시켜서 O(n) 시간 안에 구하는 방법.

A의 값을 m 이라고 고정하고 m ^ C를 했을시 이가 B와 일치하는지를 확인한다.

다만 구간을 결정하려 2번 도는 것은 n^2 짜리 시간복잡도이므로, 
조금 더 효율적으로 누적 xor 값이 목표값(m)이 되는 subarrary의 갯수를 구하는 방법을 찾아야 한다.

조금 더 논리적으로 쓸 필요가 있겠다.




