### [결론]
- N이 소수인지 아닌지를 구분하려고 한다고 하자.
- N까지의 모든 수에 대해 소수 여부를 결정하는 것과 N 하나가 소수인지 아닌지 구분하는 것의 구현방식은 크게 다르지 않다.
- 어차피 sqrt(N) 이하의 소수에 대해 체로 구해야하기에, 
다르지 병신아.

1. N 하나가 소수인지 아닌지 판별한다.
	-> sqrt(N)까지의 소수를 체로 구하고 N을 해당 소수들로 소수인지 아닌지 판별한다.

2. N까지 모든 소수에 대해 체크한다.
	-> 이러면 sqrt(N) 까지의 소수를 구하고 그 소수들로 하나씩 확인하기보다 그냥 N까지의 체를 구하는게 더 효율적이기 때문에, N까지 체를 구해나가며 소수 판별을 진행한다.

---

에라토스테네스의 체

내가 알고 싶은 소수의 범위.
-> 미리 필요한 소수들을 계산해서 저장해둔다.
sqrt(n)까지.

sqrt(n) 이하의 소수로 해당 수가 소수인지 아닌지 충분히 판별이 가능하기 때문.

n 아래의 모든 소수를 구하고 싶어!

n까지의 모든 수에 대해 체를 만드는 것은 
-> 결국 모든 수에 대해 소수라면 해당 소수의 배수에 대해 x체크.

-> 이거랑 모든 수에 대해 그 수보다 작은 소수들에 대해 모두 나뉘어지지 않는지 검사하는 거랑 어느 것이 더 효율적이지?


### sqrt(n)까지 소수 구하는 법.
- 방법 1
<pre><code>
// sqrt(100) 이하의 소수들을 구해놓는다.
    int check[11] = {}, prime[11] = {}, pidx = 0;
    int limit = sqrt(endnum) + 1;

    // limit * limit 까지 = n번. 
    for(int i = 2; i <= limit; i++){
        if(check[i]) continue;
        prime[pidx++] = i;
        for(int j = i; j <= limit; j += i){
            check[j] = 1;
        }
    }
</code></pre>

- 방법 2
<pre><code>
// sqrt(100) 이하의 소수들을 구해놓는다.
    int check[11] = {}, prime[11] = {}, pidx = 0;
    int limit = sqrt(endnum) + 1;

    // limit * limit 까지 = n번. 
    for(int i = 2; i <= limit; i++){
        if(check[i]) continue;
        prime[pidx++] = i;
		// i가 소수라면 i * i까지는 모두 check 됐다.()
        for(int j = i * i; j <= limit; j += i){
            check[j] = 1;
        }
    }
</code></pre>

방법 1과 2중 어느 것이 더 빠른가?
애매. 그래도 미리 소수에 배수에 대해서 다 빼준 것이 그 수를 어차피 방문해야 한다면 검사 없이 넘어가는 것이 그 때 가서 크기가 더 작은 소수들 중에 어느 것으로 나뉘어 질 수 있는지 확인하는 것보다 빠르지 않을까?

: 아래에서도 말했지만 n 하나만 구하는 경우에는 sqrt(n)까지만 체를 구하고 n이 소수인지 구한 소수들로 검사한다. n아래의 모든 소수를 구하는 경우에는 그냥 체를 n까지 구하는게 더 효율적이다.

----
